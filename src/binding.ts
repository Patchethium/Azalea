
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async clearCaches() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_caches") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async pickCore() : Promise<CoreConfig | null> {
    return await TAURI_INVOKE("pick_core");
},
async downloadCore(url: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_core", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async initConfig() : Promise<Result<AzaleaConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getConfig() : Promise<Result<AzaleaConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setConfig(config: AzaleaConfig) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_config", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Load the voicevox core and create lru cache
 */
async initCore(config: CoreConfig) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("init_core", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets metas from voicevox core
 */
async getMetas() : Promise<Result<CharacterMeta[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_metas") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRange() : Promise<Result<Partial<{ [key in StyleId]: [number, number] }>, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_range") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Encodes text into audio query
 */
async audioQuery(text: string, speakerId: StyleId) : Promise<Result<AudioQuery, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("audio_query", { text, speakerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Encodes text into accent phrases
 */
async accentPhrases(text: string, speakerId: StyleId) : Promise<Result<AccentPhrase[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("accent_phrases", { text, speakerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Replace mora data (pitch and duration) in accent phrases
 */
async replaceMora(ap: AccentPhrase[], styleId: StyleId) : Promise<Result<AccentPhrase[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("replace_mora", { ap, styleId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Replace pitch in accent phrases
 */
async replaceMoraPitch(ap: AccentPhrase[], styleId: StyleId) : Promise<Result<AccentPhrase[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("replace_mora_pitch", { ap, styleId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Replace duration in accent phrases
 */
async replaceMoraDuration(ap: AccentPhrase[], styleId: StyleId) : Promise<Result<AccentPhrase[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("replace_mora_duration", { ap, styleId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Synthesizes audio from audio query and put it into cache.
 * 
 * It doesn't guarantee the cached waveform is always there,
 * so the edge guard is still needed when retrieving from cache.
 * 
 * It's used in buffering audio generation in the background to reduce latency,
 * also needs to be async so that it can be invoked in the background.
 * 
 * TODO: invoke an event when wavform is dropped from cache so that frontend can be notified
 * or find another way to guarantee the viability of the cached waveforms.
 */
async synthesize(audioQuery: AudioQuery, speakerId: StyleId) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("synthesize", { audioQuery, speakerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check the synthesis state in cache
 * 
 * The frontend will poll this to keep track of the synthesis progress for each text blocks.
 */
async synthesizeState(query: AudioQuery, speakerId: StyleId) : Promise<Result<SynthState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("synthesize_state", { query, speakerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async playAudio(audioQuery: AudioQuery, speakerId: StyleId) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("play_audio", { audioQuery, speakerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save the audio waveform to a file
 */
async saveAudio(path: string, audioQuery: AudioQuery, speakerId: StyleId) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_audio", { path, audioQuery, speakerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async spectrogram(signal: number[]) : Promise<number[][]> {
    return await TAURI_INVOKE("spectrogram", { signal });
},
async getOs() : Promise<OS> {
    return await TAURI_INVOKE("get_os");
},
async quit() : Promise<void> {
    await TAURI_INVOKE("quit");
},
async saveProject(project: Project, path: string, allowCreate: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_project", { project, path, allowCreate }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadProject(path: string) : Promise<Result<Project, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_project", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * AccentPhrase (アクセント句ごとの情報)。
 * 
 * # Validation
 * 
 * この構造体の状態によっては、`Synthesizer`の各メソッドは[`ErrorKind::InvalidQuery`]を表わすエラーを返す。詳細は[`validate`メソッド]にて。
 * 
 * [`ErrorKind::InvalidQuery`]: crate::ErrorKind::InvalidQuery
 * [`validate`メソッド]: Self::validate
 */
export type AccentPhrase = { 
/**
 * モーラの配列。
 */
moras: Mora[]; 
/**
 * アクセント箇所。
 */
accent: number; 
/**
 * 後ろに無音を付けるかどうか。
 */
pause_mora: Mora | null; 
/**
 * 疑問系かどうか。
 */
is_interrogative?: boolean }
/**
 * AudioQuery (音声合成用のクエリ)。
 * 
 * # Serde
 * 
 * [Serde]においては[`accent_phrases`]を除くフィールド名はsnake\_caseの形ではなく、VOICEVOX
 * ENGINEに合わせる形でcamelCaseになっている。ただし今後の破壊的変更にて変わる可能性がある。[データのシリアライゼーション]を参照。
 * 
 * [`accent_phrases`]: Self::accent_phrases
 * [Serde]: serde
 * [データのシリアライゼーション]: https://github.com/VOICEVOX/voicevox_core/blob/main/docs/guide/user/serialization.md
 * 
 * # Validation
 * 
 * この構造体の状態によっては、`Synthesizer`の各メソッドは[`ErrorKind::InvalidQuery`]を表わすエラーを返す。詳細は[`validate`メソッド]にて。
 * 
 * [`ErrorKind::InvalidQuery`]: crate::ErrorKind::InvalidQuery
 * [`validate`メソッド]: Self::validate
 */
export type AudioQuery = { 
/**
 * アクセント句の配列。
 */
accent_phrases: AccentPhrase[]; 
/**
 * 全体の話速。
 * 
 * # Serde
 * 
 * [Serde]においては`speedScale`という名前で扱われる。
 * 
 * [Serde]: serde
 */
speedScale: number; 
/**
 * 全体の音高。
 * 
 * # Serde
 * 
 * [Serde]においては`pitchScale`という名前で扱われる。
 * 
 * [Serde]: serde
 */
pitchScale: number; 
/**
 * 全体の抑揚。
 * 
 * # Serde
 * 
 * [Serde]においては`intonationScale`という名前で扱われる。
 * 
 * [Serde]: serde
 */
intonationScale: number; 
/**
 * 全体の音量。
 * 
 * # Serde
 * 
 * [Serde]においては`volumeScale`という名前で扱われる。
 * 
 * [Serde]: serde
 */
volumeScale: number; 
/**
 * 音声の前の無音時間。
 * 
 * # Serde
 * 
 * [Serde]においては`prePhonemeLength`という名前で扱われる。
 * 
 * [Serde]: serde
 */
prePhonemeLength: number; 
/**
 * 音声の後の無音時間。
 * 
 * # Serde
 * 
 * [Serde]においては`postPhonemeLength`という名前で扱われる。
 * 
 * [Serde]: serde
 */
postPhonemeLength: number; 
/**
 * 音声データの出力サンプリングレート。
 * 
 * # Serde
 * 
 * [Serde]においては`outputSamplingRate`という名前で扱われる。
 * 
 * [Serde]: serde
 */
outputSamplingRate: number; 
/**
 * 音声データをステレオ出力するか否か。
 * 
 * # Serde
 * 
 * [Serde]においては`outputStereo`という名前で扱われる。
 * 
 * [Serde]: serde
 */
outputStereo: boolean; 
/**
 * \[読み取り専用\] AquesTalk風記法。
 * 
 * [`Synthesizer::create_audio_query`]が返すもののみ`Some`となる。入力としてのAudioQueryでは無視され
 * る。
 * 
 * [`Synthesizer::create_audio_query`]: crate::blocking::Synthesizer::create_audio_query
 */
kana: string | null }
export type AzaleaConfig = { core_config: CoreConfig | null; ui_config: UIConfig; system_presets?: Preset[] }
/**
 * <i>キャラクター</i>のメタ情報。
 */
export type CharacterMeta = { 
/**
 * キャラクター名。
 */
name: string; 
/**
 * キャラクターに属するスタイル。
 */
styles: StyleMeta[]; 
/**
 * キャラクターのバージョン。
 */
version: CharacterVersion; 
/**
 * キャラクターのUUID。
 */
speaker_uuid: string; 
/**
 * キャラクターの順番。
 * 
 * `CharacterMeta`の列は、この値に対して昇順に並んでいるべきである。
 */
order: number | null }
/**
 * [<i>キャラクター</i>]のバージョン。
 * 
 * [<i>キャラクター</i>]: CharacterMeta
 */
export type CharacterVersion = string
export type CoreConfig = { 
/**
 * The Path to the core directory, it should be the directory containing the dynamic library.
 * For example, if the lib is in `/home/user/VOICEVOX/vv-engine/libvoicevox_core.so`,
 * the path should be `/home/user/VOICEVOX/vv-engine`.
 */
ort_path: string; ojt_dir: string; vvm_dir: string; cache_size?: number }
export type Locale = "Ja" | "En"
/**
 * モーラ（子音＋母音）ごとの情報。
 * 
 * # Validation
 * 
 * この構造体の状態によっては、`Synthesizer`の各メソッドは[`ErrorKind::InvalidQuery`]を表わすエラーを返す。詳細は[`validate`メソッド]にて。
 * 
 * [`ErrorKind::InvalidQuery`]: crate::ErrorKind::InvalidQuery
 * [`validate`メソッド]: Self::validate
 */
export type Mora = { 
/**
 * 文字。
 */
text: string; 
/**
 * 子音の音素。
 */
consonant: string | null; 
/**
 * 子音の音長。
 */
consonant_length: number | null; 
/**
 * 母音の音素。
 */
vowel: string; 
/**
 * 母音の音長。
 */
vowel_length: number; 
/**
 * 音高。
 */
pitch: number }
export type OS = "MacOS" | "Windows" | "Linux"
export type Preset = { name: string; style_id: StyleId; 
/**
 * in percentage, 50-200
 */
speed: number; 
/**
 * linear shift in log hz, -1-1.
 */
pitch: number; intonation: number; volume: number; 
/**
 * in seconds, 0.0-3.0, 0 is default for no slience
 */
start_slience: number; 
/**
 * in seconds, 0.0-3.0, 0 is default for no slience
 */
end_slience: number }
export type Project = { blocks: TextBlockProps[]; presets: Preset[] }
/**
 * スタイルID。
 * 
 * VOICEVOXにおける、ある[<i>キャラクター</i>]のある[<i>スタイル</i>]を指す。
 * 
 * [<i>キャラクター</i>]: CharacterMeta
 * [<i>スタイル</i>]: StyleMeta
 */
export type StyleId = number
/**
 * <i>スタイル</i>のメタ情報。
 */
export type StyleMeta = { 
/**
 * スタイルID。
 */
id: StyleId; 
/**
 * スタイル名。
 */
name: string; 
/**
 * スタイルに対応するモデルの種類。
 */
type?: StyleType; 
/**
 * スタイルの順番。
 * 
 * [`CharacterMeta::styles`]は、この値に対して昇順に並んでいるべきである。
 */
order: number | null }
/**
 * [<i>スタイル</i>]に対応するモデルの種類。
 * 
 * # Serde
 * 
 * [Serde]においては各バリアント名はsnake\_caseとなる。
 * 
 * [<i>スタイル</i>]: StyleMeta
 * [Serde]: serde
 */
export type StyleType = 
/**
 * 音声合成クエリの作成と音声合成が可能。
 * 
 * # Serde
 * 
 * [Serde]においては`"talk"`という値で表される。
 * 
 * [Serde]: serde
 */
"talk" | 
/**
 * 歌唱音声合成用のクエリの作成が可能。
 * 
 * # Serde
 * 
 * [Serde]においては`"singing_teacher"`という値で表される。
 * 
 * [Serde]: serde
 */
"singing_teacher" | 
/**
 * 歌唱音声合成が可能。
 * 
 * # Serde
 * 
 * [Serde]においては`"frame_decode"`という値で表される。
 * 
 * [Serde]: serde
 */
"frame_decode" | 
/**
 * 歌唱音声合成用のクエリの作成と歌唱音声合成が可能。
 * 
 * # Serde
 * 
 * [Serde]においては`"sing"`という値で表される。
 * 
 * [Serde]: serde
 */
"sing"
export type SynthState = 
/**
 * not started yet or not present in cache (dropped automatically)
 */
"UnInitialized" | 
/**
 * a synthesis task is running
 */
"Pending" | 
/**
 * synthesis is done, contains waveform
 */
"Done"
export type TextBlockProps = { text: string; query: AudioQuery | null; preset_id: number | null }
export type UIConfig = { locale?: Locale; bottom_scale?: number; auto_save?: boolean; bottom_ratio?: number; side_ratio?: number }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
