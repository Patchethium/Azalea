
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async loadConfig() : Promise<Result<AppConfig, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveConfig(cfg: AppConfig) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_config", { cfg }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadCore(cfg: CoreConfig) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_core", { cfg }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async range() : Promise<Result<Partial<{ [key in StyleId]: RangeItem }>, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("range") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async metas() : Promise<Result<CharacterMeta[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("metas") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async audioQuery(text: string, styleId: StyleId) : Promise<Result<AudioQuery, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("audio_query", { text, styleId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async accentPhrases(text: string, styleId: StyleId) : Promise<Result<AccentPhrase[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("accent_phrases", { text, styleId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async synthesis(query: AudioQuery, styleId: StyleId) : Promise<Result<number[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("synthesis", { query, styleId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * AccentPhrase (アクセント句ごとの情報)。
 * 
 * # Validation
 * 
 * この構造体の状態によっては、`Synthesizer`の各メソッドは[`ErrorKind::InvalidQuery`]を表わすエラーを返す。詳細は[`validate`メソッド]にて。
 * 
 * [`ErrorKind::InvalidQuery`]: crate::ErrorKind::InvalidQuery
 * [`validate`メソッド]: Self::validate
 */
export type AccentPhrase = { 
/**
 * モーラの配列。
 */
moras: Mora[]; 
/**
 * アクセント箇所。
 */
accent: number; 
/**
 * 後ろに無音を付けるかどうか。
 */
pause_mora: Mora | null; 
/**
 * 疑問系かどうか。
 */
is_interrogative?: boolean }
export type AppConfig = { core: CoreConfig | null; ui: UiConfig }
export type AppError = "OnnxruntimeLoadError" | "OpenJtalkLoadError" | "SynthesizerBuildError" | "VoiceModelFileLoadError" | "VoiceModelNotFoundError" | "VoiceModelNotLoadedError" | "AudioQueryError" | "AccentPhrasesError" | "SynthesisError" | "ConfigReadError" | "ConfigDeserializeError" | "ConfigWriteError" | "ConfigSerializeError" | "CoreNotLoadedError" | "OsConfigDirNotFoundError" | "RangeDeserializeError"
/**
 * AudioQuery (音声合成用のクエリ)。
 * 
 * # Serde
 * 
 * [Serde]においては[`accent_phrases`]を除くフィールド名はsnake\_caseの形ではなく、VOICEVOX
 * ENGINEに合わせる形でcamelCaseになっている。ただし今後の破壊的変更にて変わる可能性がある。[データのシリアライゼーション]を参照。
 * 
 * [`accent_phrases`]: Self::accent_phrases
 * [Serde]: serde
 * [データのシリアライゼーション]: https://github.com/VOICEVOX/voicevox_core/blob/main/docs/guide/user/serialization.md
 * 
 * # Validation
 * 
 * この構造体の状態によっては、`Synthesizer`の各メソッドは[`ErrorKind::InvalidQuery`]を表わすエラーを返す。詳細は[`validate`メソッド]にて。
 * 
 * [`ErrorKind::InvalidQuery`]: crate::ErrorKind::InvalidQuery
 * [`validate`メソッド]: Self::validate
 */
export type AudioQuery = { 
/**
 * アクセント句の配列。
 */
accent_phrases: AccentPhrase[]; 
/**
 * 全体の話速。
 * 
 * # Serde
 * 
 * [Serde]においては`speedScale`という名前で扱われる。
 * 
 * [Serde]: serde
 */
speedScale: number; 
/**
 * 全体の音高。
 * 
 * # Serde
 * 
 * [Serde]においては`pitchScale`という名前で扱われる。
 * 
 * [Serde]: serde
 */
pitchScale: number; 
/**
 * 全体の抑揚。
 * 
 * # Serde
 * 
 * [Serde]においては`intonationScale`という名前で扱われる。
 * 
 * [Serde]: serde
 */
intonationScale: number; 
/**
 * 全体の音量。
 * 
 * # Serde
 * 
 * [Serde]においては`volumeScale`という名前で扱われる。
 * 
 * [Serde]: serde
 */
volumeScale: number; 
/**
 * 音声の前の無音時間。
 * 
 * # Serde
 * 
 * [Serde]においては`prePhonemeLength`という名前で扱われる。
 * 
 * [Serde]: serde
 */
prePhonemeLength: number; 
/**
 * 音声の後の無音時間。
 * 
 * # Serde
 * 
 * [Serde]においては`postPhonemeLength`という名前で扱われる。
 * 
 * [Serde]: serde
 */
postPhonemeLength: number; 
/**
 * 音声データの出力サンプリングレート。
 * 
 * # Serde
 * 
 * [Serde]においては`outputSamplingRate`という名前で扱われる。
 * 
 * [Serde]: serde
 */
outputSamplingRate: number; 
/**
 * 音声データをステレオ出力するか否か。
 * 
 * # Serde
 * 
 * [Serde]においては`outputStereo`という名前で扱われる。
 * 
 * [Serde]: serde
 */
outputStereo: boolean; 
/**
 * \[読み取り専用\] AquesTalk風記法。
 * 
 * [`Synthesizer::create_audio_query`]が返すもののみ`Some`となる。入力としてのAudioQueryでは無視され
 * る。
 * 
 * [`Synthesizer::create_audio_query`]: crate::blocking::Synthesizer::create_audio_query
 */
kana: string | null }
/**
 * <i>キャラクター</i>のメタ情報。
 */
export type CharacterMeta = { 
/**
 * キャラクター名。
 */
name: string; 
/**
 * キャラクターに属するスタイル。
 */
styles: StyleMeta[]; 
/**
 * キャラクターのバージョン。
 */
version: CharacterVersion; 
/**
 * キャラクターのUUID。
 */
speaker_uuid: string; 
/**
 * キャラクターの順番。
 * 
 * `CharacterMeta`の列は、この値に対して昇順に並んでいるべきである。
 */
order: number | null }
/**
 * [<i>キャラクター</i>]のバージョン。
 * 
 * [<i>キャラクター</i>]: CharacterMeta
 */
export type CharacterVersion = string
export type CoreConfig = { ort_path: string; ojt_dir: string; vvm_dir: string }
/**
 * モーラ（子音＋母音）ごとの情報。
 * 
 * # Validation
 * 
 * この構造体の状態によっては、`Synthesizer`の各メソッドは[`ErrorKind::InvalidQuery`]を表わすエラーを返す。詳細は[`validate`メソッド]にて。
 * 
 * [`ErrorKind::InvalidQuery`]: crate::ErrorKind::InvalidQuery
 * [`validate`メソッド]: Self::validate
 */
export type Mora = { 
/**
 * 文字。
 */
text: string; 
/**
 * 子音の音素。
 */
consonant: string | null; 
/**
 * 子音の音長。
 */
consonant_length: number | null; 
/**
 * 母音の音素。
 */
vowel: string; 
/**
 * 母音の音長。
 */
vowel_length: number; 
/**
 * 音高。
 */
pitch: number }
export type RangeItem = { Normal: [number, number] } | "Whisper"
/**
 * スタイルID。
 * 
 * VOICEVOXにおける、ある[<i>キャラクター</i>]のある[<i>スタイル</i>]を指す。
 * 
 * [<i>キャラクター</i>]: CharacterMeta
 * [<i>スタイル</i>]: StyleMeta
 */
export type StyleId = number
/**
 * <i>スタイル</i>のメタ情報。
 */
export type StyleMeta = { 
/**
 * スタイルID。
 */
id: StyleId; 
/**
 * スタイル名。
 */
name: string; 
/**
 * スタイルに対応するモデルの種類。
 */
type?: StyleType; 
/**
 * スタイルの順番。
 * 
 * [`CharacterMeta::styles`]は、この値に対して昇順に並んでいるべきである。
 */
order: number | null }
/**
 * [<i>スタイル</i>]に対応するモデルの種類。
 * 
 * # Serde
 * 
 * [Serde]においては各バリアント名はsnake\_caseとなる。
 * 
 * [<i>スタイル</i>]: StyleMeta
 * [Serde]: serde
 */
export type StyleType = 
/**
 * 音声合成クエリの作成と音声合成が可能。
 * 
 * # Serde
 * 
 * [Serde]においては`"talk"`という値で表される。
 * 
 * [Serde]: serde
 */
"talk" | 
/**
 * 歌唱音声合成用のクエリの作成が可能。
 * 
 * # Serde
 * 
 * [Serde]においては`"singing_teacher"`という値で表される。
 * 
 * [Serde]: serde
 */
"singing_teacher" | 
/**
 * 歌唱音声合成が可能。
 * 
 * # Serde
 * 
 * [Serde]においては`"frame_decode"`という値で表される。
 * 
 * [Serde]: serde
 */
"frame_decode" | 
/**
 * 歌唱音声合成用のクエリの作成と歌唱音声合成が可能。
 * 
 * # Serde
 * 
 * [Serde]においては`"sing"`という値で表される。
 * 
 * [Serde]: serde
 */
"sing"
export type UiConfig = Record<string, never>

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
